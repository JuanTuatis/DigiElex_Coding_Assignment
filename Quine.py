# -*- coding: utf-8 -*-
"""Quine-Mccluskey Coding Assignment - 11/28/23 ver

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18DXW9XXYV90psuddCwR9xN06T3bdTrsA
"""

#Quine McClaukey Method(Tabular)
#Introductory:
print('\nCreated by:')
print('Joachim Gonzales and Juan Francis Tuatis')
print('BSECE-3C')

#Importing Libraries
import pandas as pd
from numpy import binary_repr
import os #To restart the program
import sys #Same with this since its coombine with import os that takes two arguments

#Functional Programming

#Number of terms
def multi_minterms(x , y):
    res = []
    for i in x:
        if i + "'" in y or (len(i) == 2 and i[0] in y):
            return []
        else:
            res.append(i)
    for i in y:
        if i not in res:
            res.append(i)

    return res

#Combining binary inputs
def combine(x , y):
    mult_mints = []
    for i in x:
        for j in y:
            temp = multi_minterms(i , j)
            mult_mints.append(temp) if len(temp) != 0 else None
    return mult_mints

#Default variable starting from A. Dependent to the vars input
def find_vars(x):
    var_list = []
    for i in range(len(x)):
        if x[i] == '0':
            var_list.append(chr(i+65)+"'")
        elif x[i] == '1':
            var_list.append(chr(i+65))
    return var_list

#Function for finding out which minterms are grouped
def find_minterms(a):
    grouped_mints = []
    gaps = a.count('-')
    if gaps == 0:
        return [str(int(a,2))]

    x = [bin(i)[2:].zfill(gaps) for i in range(pow(2,gaps))]
    for i in range(pow(2,gaps)):
        temp2,ind = a[:],-1
        for j in x[0]:
            if ind != -1:
                ind = ind+temp2[ind+1:].find('-')+1
            else:
                ind = temp2[ind+1:].find('-')
            temp2 = temp2[:ind]+j+temp2[ind+1:]
        grouped_mints.append(str(int(temp2,2)))
        x.pop(0)
    return grouped_mints

#Appending new value which will be use to the while loop
def trans(x):
    flat = []
    for items in x:
        flat.extend(x[items])
    return flat

# Function for checking if 2 minterms differ by 1 bit only
def bin_comp(a,b):
    c = 0
    for i in range(len(a)):
        if a[i] != b[i]:
            change = i
            c += 1
            if c>1:
                return (False,None)
    return (True,change)

#Inputs

var = int(input('How many variables will be used? '))
lower_lim = 0
upper_lim = 2**var - 1
store_minterm = {}
mint = [int(i) for i in input(f'Enter the minterms. Between {lower_lim} and {upper_lim}. Should be Separated by Commas: ').split(" ")]
dc = [int(i) for i in input("Enter the don't cares(If any. Leave blank if None): ").strip().split()]
binary_list = []
minterms = mint + dc


#Checking if the inputs exceeded to the upper limit
try:
    if any(minterm < 0 or minterm > upper_lim for minterm in minterms):
        raise ValueError(f'Minterms must be betwwen {lower_lim} and {upper_lim}')

    minterms.sort()
    for item in range(0 , len(minterms)):
        binary_list.append(binary_repr(minterms[item], var))
        store_minterm =dict(zip(minterms , binary_list))
    tabulated = pd.DataFrame(list(store_minterm.items()), columns= ['Minterms' , 'Binary'])
    print(tabulated)
except ValueError as w:
    print("Error:" , w)

group , prime_implicants = {} , set()

for minterm in minterms:
    try:
        group[binary_repr(minterm , var).count('1')].append(binary_repr(minterm , var))

    except KeyError:
        group[binary_repr(minterm , var).count('1')] = [binary_repr(minterm , var)]

#Grouping of Binary
listed = []
for key , value in group.items():
    for i in range(len(value)):
        listed.append([key , int(value[i] , 2) , value[i]])


listed_df = pd.DataFrame(listed , columns = ['Group' , 'Minterms' , 'Binary'])
print(listed_df)


#This loop itterated until there are no binary to group to be a prime implicants
while True:
    temp = group.copy()
    group , mints , marked , stop = {},0,set() , True

    listed = sorted(list(temp.keys()))

    for i in range(len(listed) - 1):
        for j in temp[listed[i]]:
            for k in temp[listed[i + 1]]:
                res = bin_comp(j , k)
                if res[0]:
                    try:
                        group[mints].append(j[:res[1]]+'-'+j[res[1]+1:]) if j[:res[1]]+'-'+j[res[1]+1:] not in group[mints] else None

                    except KeyError:
                        group[mints] = [j[:res[1]] + '-' + j[res[1] + 1:]]
                    stop = False
                    marked.add(j)
                    marked.add(k)
        mints += 1

    unmarked = set(trans(temp)).difference(marked)
    prime_implicants = prime_implicants.union(unmarked)

    if unmarked:
        unmarked_df = pd.DataFrame(list(unmarked), columns=['Binary'])
        print('\nUnmarked Prime Implicants')
        print(unmarked_df)
    else:
        print('None')

    if stop:
        break

    lis = []

    for key , value in group.items():
        for i in range(len(value)):
            lis.append([key , find_minterms(value[i]) , value[i]])

    lis_df = pd.DataFrame(lis , columns=['Group' , 'Minterms' , 'Binary'])
    print('\n',lis_df)

print('\n')


#The following table utilize the petrick table since this more accurate than the last algorithm
sz = len(str(mint[-1]))
tabulated = {}

for i in range(var):
    print(chr(i + 65) , end =' ')

print(' '.join((' '*(sz-len(str(mt))))+str(mt) for mt in mint))

for prime_table in prime_implicants:
    combine_minterm , y , dont_care = find_minterms(prime_table) , 0 , []

    print(' '.join(list(prime_table)), end=' ')
    for orig_minterm in combine_minterm:
        if int(orig_minterm) not in dc:
            dont_care.append(orig_minterm)

    for minterm in dont_care:
        x = mint.index(int(minterm))*(sz + 1)
        print(' '*abs(x-y)+' '*(sz-1)+'X',end='')
        y = x+sz
        try:
            tabulated[minterm].append(prime_table) if prime_table not in tabulated[minterm] else None
        except KeyError:
            tabulated[minterm] = [prime_table]

    print('\n')


epi = []

#Checking if there's a possible prime implicants in the inputs
for key_mint in tabulated:
    if len(tabulated[key_mint]) == 1:
        epi.append(tabulated[key_mint][0]) if tabulated[key_mint][0] not in epi else None

if epi:
    epi_df = pd.DataFrame(list(epi) , columns=['Binary'])
    print('\nEssential Prime Implicants')
else:
    print('None')

for group_epi in epi:
    for group_minterm in find_minterms(group_epi):
        try:
            del tabulated[group_minterm]
        except KeyError:
            pass

if(len(tabulated) == 0):
    answer = [find_vars(group_epi) for group_epi in epi]

else:
    P = [[find_vars(j) for j in tabulated[i]] for i in tabulated]
    boolean_expression = {}
    mapping = {}
    count = 1

    for i in range(len(P)):
        for j in range(len(P[i])):
            P[i][j].sort()

            if tuple(P[i][j]) in boolean_expression:
                P[i][j] = [boolean_expression[tuple(P[i][j])]]
            else:
                boolean_expression[tuple(P[i][j])] = "P" + str(count)
                mapping['P' + str(count)] = P[i][j]
                P[i][j] = [boolean_expression[tuple(P[i][j])]]
                count += 1

    while len(P) > 1:
        P[1] = combine(P[0] , P[1])
        P.pop(0)

    answer = [min(P[0] , key=len)]
    answer = [mapping[variable] for variable in answer[0]]
    answer.extend(find_vars(i) for i in epi)

print('\n\nSolution: F = '+' + '.join(''.join(i) for i in answer))


while True:
    program = input('Create a new one(Yes/No): ').upper()

    if program.upper() == 'Y' or program.upper() == 'Yes':
        print("Wait for the program...")
        os.execv(sys.executable, [sys.executable, __file__ ])
    elif program.upper() == 'N' or program.upper() == 'No':
        print('Closing the program...')
        exit()
    else:
        print('Invalid option')